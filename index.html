\
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unforced Errors Open 2025</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.35; }
    h1 { margin-top: 0; }
    section { margin: 2rem 0; }
    .pots { display: grid; grid-template-columns: repeat(2, minmax(260px, 1fr)); gap: 1rem; }
    .pot-grid { display: grid; grid-template-columns: 1fr; gap: .25rem; }
    .pot-grid input { width: 100%; padding: .5rem .6rem; border: 1px solid #ccc; border-radius: 8px; }
    .primary { margin-top: .6rem; padding: .6rem 1rem; border-radius: 8px; border: 0; background: #155eef; color: #fff; font-weight: 600; cursor: pointer; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: .6rem; }
    label { display: grid; gap: .25rem; font-size: .95rem; }
    .table { overflow-x: auto; }
    table { border-collapse: collapse; width: 100%; margin-top: .75rem; }
    th, td { border: 1px solid #ddd; padding: .4rem .5rem; text-align: center; }
    th { background: rgba(0,0,0,.05); }
    .match-row { display: flex; flex-wrap: wrap; align-items: center; gap: .5rem; padding: .25rem 0; }
    .match-row input[type="number"] { width: 4.5rem; padding: .3rem .4rem; }
    .hint { font-size: .9rem; opacity: .7; }
    .muted { opacity: .6; }
    .row { display:flex; gap:.6rem; align-items:center; flex-wrap:wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .two-col { display:grid; grid-template-columns: 1fr 1fr; gap:1rem; }
  </style>
</head>
<body>
  <h1>Unforced Errors Open 2025</h1>
 
  <section id="section-players">
    <h2>Spieler eingeben</h2>
    <p>Trage bis zu <strong>7 Spieler</strong> pro Lostopf ein. Beide Töpfe müssen die gleiche Anzahl an Spielern enthalten.</p>
    <div class="pots">
      <div class="pot">
        <h3>Topf A</h3>
        <div id="potA" class="pot-grid">
          <input type="text" placeholder="Spieler 1">
          <input type="text" placeholder="Spieler 2">
          <input type="text" placeholder="Spieler 3">
          <input type="text" placeholder="Spieler 4">
          <input type="text" placeholder="Spieler 5">
          <input type="text" placeholder="Spieler 6">
          <input type="text" placeholder="Spieler 7">
        </div>
      </div>
      <div class="pot">
        <h3>Topf B</h3>
        <div id="potB" class="pot-grid">
          <input type="text" placeholder="Spieler 1">
          <input type="text" placeholder="Spieler 2">
          <input type="text" placeholder="Spieler 3">
          <input type="text" placeholder="Spieler 4">
          <input type="text" placeholder="Spieler 5">
          <input type="text" placeholder="Spieler 6">
          <input type="text" placeholder="Spieler 7">
        </div>
      </div>
    </div>
    <button id="btnTeams" class="primary">Teams generieren</button>
    <p class="hint">Nach der Auslosung kannst du pro Team einen <strong>Anzeigenamen</strong> (z. B. „Team RacketX“) vergeben. Die Spieler‑Namen bleiben intern erhalten. Im Spielplan/Ergebnissen wird <strong>nur</strong> der Anzeigename oder „Tn“ angezeigt.</p>
    <div id="teams"></div>
  </section>

  <section id="section-overview" style="display:none;">
    <h2>Teams (Übersicht)</h2>
    <div id="teamsTable"></div>
  </section>

  <section>
    <h2>Spielplan (Courts 5 · 6 · 7)</h2>
    <div class="row">
      <button id="btnSchedule" class="primary">Spielplan erzeugen</button>
      <button id="btnShare" class="primary" disabled>Turnier‑Link erzeugen & teilen</button>
      <span id="shareInfo" class="mono"></span>
    </div>
    <div id="schedule"></div>
  </section>

  <section>
    <h2>Ergebnisse erfassen</h2>
    <p class="hint">Nur Zahlen <strong>0–4</strong>. <strong>4–3</strong> wird automatisch als Tie‑Break gewertet. Es gibt <strong>kein Unentschieden</strong>.</p>
    <div id="results"></div>
    <button id="btnTable" class="primary">Tabelle berechnen</button>
    <div id="table"></div>
  </section>

  <section>
    <h2>Finals (Court 5)</h2>
    <button id="btnFinals" class="primary">Finals planen</button>
    <div id="finals"></div>
  </section>

  <footer>
    <small>© 2025 Unforced Errors Open</small>
  </footer>

  <script>
  // ===== Helpers & state =====
  const $ = sel => document.querySelector(sel);
  function shuffle(arr){ return arr.map(v=>({v, r: Math.random()})).sort((a,b)=>a.r-b.r).map(x=>x.v); }
  function clamp04(val){ if(val===''||val===null||val===undefined) return ''; const n=parseInt(val,10); if(isNaN(n)) return ''; return Math.max(0, Math.min(4, n)); }
  function inferTB(g1,g2){ const max=Math.max(g1,g2), min=Math.min(g1,g2); return (max===4 && min===3); }

  const state = {
    id: null,         // shared id if /t/:id
    teams: [],        // {id:'T1', players:'A & B', alias:''}
    matches: [],      // {round, court, team1Id, team2Id, result?}
    locked: false,    // if true, alias inputs disabled (shared URL)
  };

  // ===== Core logic =====
  function makeTeams(potA, potB){
    if (potA.length !== potB.length) throw new Error('Beide Lostöpfe müssen die gleiche Anzahl Namen haben.');
    if (potA.length === 0) throw new Error('Mindestens 1 Spieler pro Topf erforderlich.');
    if (potA.length > 7) throw new Error('Maximal 7 Spieler pro Topf.');
    const b = shuffle(potB);
    state.teams = potA.map((a,i)=>({ id:`T${i+1}`, players:`${a} & ${b[i]}`, alias:'' }));
  }
  function roundRobin(ids){ const a=[...ids]; if(a.length%2===1) a.push('__BYE__'); const m=a.length, rounds=[]; for(let r=0;r<m-1;r++){ const p=[]; for(let i=0;i<m/2;i++){ const h=a[i], g=a[m-1-i]; if(h!=='__BYE__'&&g!=='__BYE__') p.push([h,g]); } rounds.push({round:r+1,pairs:p}); const f=a[0], rest=a.slice(1); rest.unshift(rest.pop()); a.splice(0,m,f,...rest);} return rounds; }
  function scheduleOnCourts(rounds){ const courts=[5,6,7]; state.matches=[]; for(const r of rounds){ let i=0; while(i<r.pairs.length){ for(const c of courts){ if(i>=r.pairs.length) break; const [t1,t2]=r.pairs[i++]; state.matches.push({ round:r.round, court:c, team1Id:t1, team2Id:t2 }); } } } }
  const teamDisplay = id => { const t=state.teams.find(x=>x.id===id); return t? (t.alias?.trim()||t.id) : id; };

  // ===== Rendering =====
  function renderTeamsEditor(){
    const html = state.teams.map(t=>`
      <div class="two-col">
        <div><strong>${t.id}</strong> – Spieler: ${t.players}</div>
        <div><label>Anzeigename <input type="text" value="${t.alias||''}" data-id="${t.id}" ${state.locked?'disabled':''}></label></div>
      </div>`).join('');
    $('#teams').innerHTML = html;
    if(!state.locked){
      $('#teams').querySelectorAll('input[data-id]').forEach(inp=>{
        inp.addEventListener('input', e=>{ const id=e.target.getAttribute('data-id'); const t=state.teams.find(x=>x.id===id); if(t){ t.alias=e.target.value; drawOverview(); drawSchedule(); drawResults(); } });
      });
    }
    drawOverview();
  }

  function drawOverview(){
    const rows = state.teams.map(t=>`<tr><td>${t.id}</td><td>${t.players.split(' & ')[0]}</td><td>${t.players.split(' & ')[1]}</td><td>${t.alias?.trim()||t.id}</td></tr>`).join('');
    $('#teamsTable').innerHTML = `<div class="table"><table><thead><tr><th>Team</th><th>Spieler A</th><th>Spieler B</th><th>Anzeigename</th></tr></thead><tbody>${rows}</tbody></table></div>`;
    $('#section-overview').style.display = state.teams.length? 'block' : 'none';
  }

  function drawSchedule(){ const rows = state.matches.map(m=>`<tr><td>${m.round}</td><td>${m.court}</td><td>${teamDisplay(m.team1Id)} vs ${teamDisplay(m.team2Id)}</td></tr>`).join(''); $('#schedule').innerHTML = `<div class="table"><table><thead><tr><th>Runde</th><th>Court</th><th>Teams</th></tr></thead><tbody>${rows}</tbody></table></div>`; }

  function drawResults(){ const html = state.matches.map((m,idx)=>`<div class="match-row" data-i="${idx}"><strong>R${m.round}</strong> · Court ${m.court} · ${teamDisplay(m.team1Id)} vs ${teamDisplay(m.team2Id)} <input type="number" min="0" max="4" step="1" placeholder="0–4" data-side="1" /> <input type="number" min="0" max="4" step="1" placeholder="0–4" data-side="2" /> <span class="hint" data-hint="${idx}"></span></div>`).join(''); $('#results').innerHTML = html;
    $('#results').querySelectorAll('.match-row').forEach(row=>{
      const idx = parseInt(row.getAttribute('data-i'),10);
      const inps = row.querySelectorAll('input[type="number"]');
      inps.forEach(inp=>{ inp.addEventListener('input', async ()=>{
        inp.value = clamp04(inp.value);
        const g1 = inps[0].value===''? null : parseInt(inps[0].value,10);
        const g2 = inps[1].value===''? null : parseInt(inps[1].value,10);
        const hint = row.querySelector('[data-hint]');
        if (g1===null || g2===null){ delete state.matches[idx].result; hint.textContent=''; return; }
        // keine Unentschieden: gültig ist genau ein 4er und der andere 0..3
        const valid = ((g1===4 && g2>=0 && g2<=3) || (g2===4 && g1>=0 && g1<=3)) && !(g1===4 && g2===4);
        if (!valid){ delete state.matches[idx].result; hint.textContent=''; return; }
        const tb = (Math.max(g1,g2)===4 && Math.min(g1,g2)===3);
        state.matches[idx].result = { team1Games:g1, team2Games:g2, decidedByTB: tb };
        hint.textContent = tb? 'Tie‑Break' : '';
        // persistieren, falls shared Modus
        if(state.id){ await fetch('/.netlify/functions/update', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: state.id, index: idx, g1, g2 }) }); }
      }); }); });
  }

  function pointsFor(r,who){ const t1won = r.team1Games>r.team2Games; const won = who==='t1'? t1won : !t1won; return won ? (r.decidedByTB?2:3) : (r.decidedByTB?1:0); }
  function computeTable(){ const map=new Map(state.teams.map(t=>[t.id,{teamId:t.id, played:0, points:0, gp:0, gm:0, diff:0}])); for(const m of state.matches){ if(!m.result) continue; const r=m.result; const a=map.get(m.team1Id), b=map.get(m.team2Id); a.played++; b.played++; a.points+=pointsFor(r,'t1'); b.points+=pointsFor(r,'t2'); a.gp+=r.team1Games; a.gm+=r.team2Games; b.gp+=r.team2Games; b.gm+=r.team1Games; a.diff=a.gp-a.gm; b.diff=b.gp-b.gm; } return Array.from(map.values()); }
  function sortTable(base){ const s=[...base].sort((x,y)=> y.points-x.points || (y.diff-x.diff) || (y.gp-x.gp) || (x.gm-y.gm));
    const out=[]; let i=0; while(i<s.length){ const g=[s[i]]; let j=i+1; while(j<s.length && s[j].points===s[i].points && s[j].diff===s[i].diff && s[j].gp===s[i].gp && s[j].gm===s[i].gm){ g.push(s[j]); j++; } if(g.length===1){ out.push(g[0]); i=j; continue; } const ids=g.map(r=>r.teamId); const sub=state.matches.filter(m=>m.result && ids.includes(m.team1Id)&&ids.includes(m.team2Id)); if(g.length===2){ const [a,b]=ids; const d=sub.find(m=>(m.team1Id===a&&m.team2Id===b)||(m.team1Id===b&&m.team2Id===a)); if(d){ const aWins=d.result.team1Games>d.result.team2Games; const winId=aWins?d.team1Id:d.team2Id; const loseId=aWins?d.team2Id:d.team1Id; out.push(g.find(x=>x.teamId===winId)); out.push(g.find(x=>x.teamId===loseId)); i=j; continue; } } const miniMap=new Map(ids.map(id=>[id,{teamId:id, points:0, gp:0, gm:0}])); for(const m of sub){ const r=m.result; const a=miniMap.get(m.team1Id), b=miniMap.get(m.team2Id); a.points+=pointsFor(r,'t1'); b.points+=pointsFor(r,'t2'); a.gp+=r.team1Games; a.gm+=r.team2Games; b.gp+=r.team2Games; b.gm+=r.team1Games; } const mini=[...miniMap.values()].sort((x,y)=> y.points-x.points || ((y.gp-y.gm)-(x.gp-x.gm)) || (y.gp-x.gp) || (x.gm-y.gm)); out.push(...mini.map(mm=>g.find(x=>x.teamId===mm.teamId))); i=j; }
    return out; }

  function renderTable(){ const base=computeTable(); const sorted=sortTable(base); const rows=sorted.map((r,i)=>`<tr><td>${i+1}</td><td>${teamDisplay(r.teamId)}</td><td>${r.played}</td><td>${r.points}</td><td>${r.gp}</td><td>${r.gm}</td><td>${r.diff}</td></tr>`).join(''); $('#table').innerHTML = `<div class="table"><table><thead><tr><th>Platz</th><th>Team</th><th>Spiele</th><th>Punkte</th><th>Games+</th><th>Games−</th><th>Diff</th></tr></thead><tbody>${rows}</tbody></table></div>`; }
  function renderFinals(){ const base=computeTable(); const sorted=sortTable(base); if(sorted.length<4){ $('#finals').innerHTML=''; return; } const f=[{name:'Finale', court:5, t1:sorted[0].teamId, t2:sorted[1].teamId},{name:'Kleines Finale', court:5, t1:sorted[2].teamId, t2:sorted[3].teamId}]; const rows=f.map(x=>`<tr><td>${x.name}</td><td>${x.court}</td><td>${teamDisplay(x.t1)} vs ${teamDisplay(x.t2)}</td></tr>`).join(''); $('#finals').innerHTML = `<div class="table"><table><thead><tr><th>Spiel</th><th>Court</th><th>Teams</th></tr></thead><tbody>${rows}</tbody></table></div>`; }

  // ===== API =====
  async function apiCreate(){
    const res = await fetch('/.netlify/functions/create', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ teams: state.teams, matches: state.matches }) });
    if(!res.ok){ alert('Fehler beim Erzeugen des Turnier‑Links'); return; }
    const data = await res.json();
    state.id = data.id; state.locked = true; // ab jetzt alias gesperrt
    $('#section-players').style.display='none';
    $('#shareInfo').textContent = data.url;
    history.pushState({}, '', `/t/${data.id}`);
  }
  async function apiLoad(id){
    const res = await fetch(`/.netlify/functions/get?id=${encodeURIComponent(id)}`);
    if(!res.ok){ alert('Turnier nicht gefunden.'); return; }
    const data = await res.json();
    state.id = id; state.locked = true; state.teams = data.teams; state.matches = data.matches;
    $('#section-players').style.display='none';
    renderTeamsEditor(); drawSchedule(); drawResults();
  }

  // ===== UI events =====
  $('#btnTeams').addEventListener('click', ()=>{
    const potA = Array.from($('#potA').querySelectorAll('input')).map(i=>i.value.trim()).filter(Boolean);
    const potB = Array.from($('#potB').querySelectorAll('input')).map(i=>i.value.trim()).filter(Boolean);
    try{ makeTeams(potA,potB);}catch(e){ alert(e.message); return; }
    renderTeamsEditor();
  });
  $('#btnSchedule').addEventListener('click', ()=>{
    if(!state.teams.length){ alert('Bitte zuerst Teams generieren.'); return; }
    const rounds = roundRobin(state.teams.map(t=>t.id)); scheduleOnCourts(rounds); drawSchedule(); drawResults(); $('#btnShare').disabled=false; $('#shareInfo').textContent='';
  });
  $('#btnShare').addEventListener('click', ()=> apiCreate());
  $('#btnTable').addEventListener('click', renderTable);
  $('#btnFinals').addEventListener('click', renderFinals);

  // ===== Init: shared route /t/:id =====
  (function init(){ const parts = location.pathname.split('/').filter(Boolean); if(parts[0]==='t' && parts[1]){ apiLoad(parts[1]); } })();
  </script>
</body>
</html>
